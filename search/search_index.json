{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation of the TimeSeries library","text":"<p>TimeSeries is an Arduino library for time series forecasting.</p> <p>The library provides support for well-known statistical forecasting models, such as autoregressive and moving average models. Recursive multi-step forecasting is supported.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Dependency-free: at the moment, this library is completely dependency-free;</li> <li>Dynamic-memory-free: every model provided by the library is implemented statically using templates and circular buffers;</li> <li>Compatibility: as it makes no use of any board-specific instructions/features, this library should be compatible with almost every Arduino board;</li> <li>Support for multi-step forecasting: the library supports recursive multi-step forecasting. Although only the recursive method is implemented directly, direct methods could of course be used by instantiating multiple models. See Sahoo et al. [1] for more details on these multi-step forecasting methods.</li> </ul>"},{"location":"#documentation-guide","title":"Documentation Guide","text":"<p>A quick and simple installation guide is available in our First Steps page.</p> <p>For detailed information regarding every class, function, or method provided by the library, please refer to our API Reference.</p> <p>Finally, be sure to check out our Examples page for guidance on how to use the library.</p>"},{"location":"#references","title":"References","text":"<p>[1] Debashis Sahoo, Naveksha Sood, Usha Rani, George Abraham, Varun Dutt, and AD Dileep. Comparative analysis of multi-step time-series forecasting for network load dataset. In 2020 11th International Conference on Computing, Communication and Networking Technologies (ICCCNT), pages 1\u20137. IEEE, 2020.</p>"},{"location":"API_ref/","title":"TimeSeries API Reference","text":"<p>Welcome to the API reference of the TimeSeries Arduino library.</p> <p>Here you will find detailed information on the classes, methods, and functions that make up the library.</p> <p>If you are unsure of what to look for, take a look at the API index.</p> <p>Alternatively, you can always jump directly to the AR model class or the MA model class.</p>"},{"location":"about/","title":"About","text":"<p>This library was conceived, developed, tested, and documented by Miguel Loureiro, a Mechanical Engineer who specialises in Control Systems, Machine Learning, and Optimisation.</p>"},{"location":"installation/","title":"First steps","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>TimeSeries is available for installation via the official Arduino library index. You can therefore download it using the Arduino IDE. Alternatively, the library is available for download directly from Github.</p>"},{"location":"installation/#basic-usage","title":"Basic usage","text":"<p>See this sketch for an easy and intuitive example of how to use the library.</p>"},{"location":"models/","title":"Supported models","text":"<p>TimeSeries currently supports the following models:</p> Model Class Description One-step forecasting Multi-step forecasting AR(p) AR An autoregressive model of order p. Fully tested. Fully tested. MA(q) MA A moving average model of order q. Fully tested. Fully tested. <p>For more information on these models, see [1, 2, 3].</p> <p>When forecasting using an n<sup>th</sup> order model and a forecasting horizon of h, the time and memory complexities of the models are as follows:</p> Model Time complexity Memory complexity AR O(nh) O(2n) MA O(nh) O(3n) <p>Note: these values were simply derived from the code, and are thus purely indicative. Computational experiments will be conducted in the future.</p>"},{"location":"models/#references","title":"References","text":"<p>[1] George E.P. Box, Gwilym M. Jenkins, Gregory C. Reinsel, and Greta M. Ljung. Time series analysis: forecasting and control. John Wiley &amp; Sons, 2015.</p> <p>[2] William W.S. Wei. Time Series Analysis: Univariate and Multivariate Methods. Addison-Wesley, 2006.</p> <p>[3] Aileen Nielsen. Practical time series analysis: Prediction with statistics and machine learning. O\u2019Reilly Media, 2019.</p>"},{"location":"examples/","title":"Example Index","text":"<p>Welcome to the TimeSeries library example index.</p> <p>Here is a list of all currently available examples:</p> <ul> <li>Basic usage (one step ahead forecasting);</li> <li>Multi-step ahead forecasting;</li> <li>Change model parameters.</li> </ul>"},{"location":"examples/basics/","title":"Example - One-step ahead forecasting","text":"<p>In the following example, a 5<sup>th</sup> Autoregressive model is used to forecast the future values of a measurement using past measurement data.</p>"},{"location":"examples/basics/#example-code","title":"Example code","text":"<pre><code>/*****************************************************************************\n\n  This example illustrates how to use the library's AR template class to \n  create a simple Autoregressive model of order 5 and use it to obtain \n  a forecast for the next measurement value.\n\n  Note: the weights and constant used in this example are completely\n    arbitrary. This model will most likely perform poorly, and is used here\n    for purely illustrative purposes.\n\n*****************************************************************************/\n\n#include &lt;TimeSeries.h&gt;\n#include &lt;stdint.h&gt;\n\nconstexpr double Ts = 2000.0; // Define sampling time (2 seconds = 2000 ms).\ndouble time = millis(); // Initial time instant.\nconstexpr uint8_t input_pin = A0; // Define input pin.\n\ndouble constant = 2.0; // Define model intercept.\ndouble weights[5] = {1.0, -5.0, 2.5, -1.5, 4.0}; // Define model weights.\ndouble data[5] = {0}; // Initialise data array.\ndouble predictions[1] = {0}; // Initialise predictions array for one-step ahead forecasting.\n\nts::AR&lt;5&gt; model(weights, constant); // Instantiate the model. An AR(5) model will be used in this example.\n\nvoid setup() {\n\n  // Initial setup.\n  Serial.begin(9600);\n  pinMode(input_pin, INPUT);\n\n}\n\nvoid loop() {\n\n  double current_time = millis(); // Check the current time.\n  double forecast = 0.0; // Variable that will contain the forecast.\n\n  // If enough time has passed, collect another sample.\n  if(current_time - time &gt;= Ts){\n\n    // Prepare the data array to receive a measurement. \n    // Every sample must be shifted by one lag, as we have advanced one lag (i.e. time instant) into the future. \n    // The oldest measurement is discarded.\n    for(size_t i=4; i&lt;1; i--){\n\n      data[i-1] = data[i];\n\n    }\n\n    // Collect a new data sample from the sensor. Update the data array (the most recent sample must come last).\n    data[4] = analogRead(input_pin);\n\n    // One-step ahead forecast using the most recent data.\n    model.forecast(data, predictions);\n\n    // Print the most recent measurement and the corresponding forecast to the serial plotter.\n    Serial.print(\"Sensor_measurement\");\n    Serial.print(data[4]);\n    Serial.print(\",\");\n    Serial.print(\"Forecast\");\n    Serial.println(forecast);\n\n    // Store forecast so it can be plotted once another sample is collected.\n    forecast = predictions[0];\n\n    // Update reference time instant.\n    time = millis();\n\n  }\n\n}\n</code></pre>"},{"location":"examples/basics/#see-also","title":"See also","text":"<ul> <li>Multi-step ahead forecasting: perform multi-step ahead forecasting using the recursive forecasting method;</li> <li>Change model parameters: change model parameters after initialising a model.</li> </ul>"},{"location":"examples/change_param/","title":"Examples - Change model parameters","text":"<p>This example shows how the <code>set_weights()</code> and <code>set_constant()</code> methods can be used to change model parameters after a class instance has been created.</p>"},{"location":"examples/change_param/#example-code","title":"Example code","text":"<pre><code>/*****************************************************************************\n\n  This example illustrates how to change a model's weights after initialisation.\n\n  Note: the weights and constant used in this example are completely\n    arbitrary. This model will most likely perform poorly, and is used here\n    for purely illustrative purposes.\n\n*****************************************************************************/\n\n#include &lt;TimeSeries.h&gt;\n#include &lt;stdint.h&gt;\n\nconstexpr double elapsed_time = 10000.0; // Define sampling time (10 seconds = 10000 ms).\ndouble time = millis(); // Initial time instant.\n\n// Define initial model weights and constants.\ndouble initial_AR_constant = 2.0;\ndouble initial_AR_weights[1] = {-1.0};\ndouble initial_MA_constant = -1.0;\ndouble initial_MA_weights[1] = {3.0};\n\n// Define new model weights and constants.\ndouble new_AR_constant = -2.0;\ndouble new_AR_weights[1] = {1.0};\ndouble new_MA_constant = 1.0;\ndouble new_MA_weights[1] = {-3.0};\n\n// Instantiate the models using the initial weights.\nts::AR&lt;1&gt; ar_model(initial_AR_weights, initial_AR_constant);\nts::MA&lt;1&gt; ma_model(initial_MA_weights, initial_MA_constant);\n\nvoid setup() {\n\n  // Initial setup.\n  Serial.begin(9600);\n\n}\n\nvoid loop() {\n\n  double current_time = millis(); // Check the current time.\n  double *weights = nullptr;\n\n  // If enough time has passed, update the weights.\n  if(current_time - time &gt;= elapsed_time){\n\n    // Print the initial AR weights and constant.\n    weights = ar_model.get_weights();\n\n    Serial.print(\"Old AR(1) model weight: \");\n    Serial.print(weights[0]);\n    Serial.print(\",\");\n    Serial.print(\"Old AR(1) model constant: \");\n    Serial.print(ar_model.get_constant());\n    Serial.print(\",\");\n\n    // Change the AR weights and constant and print them.\n    ar_model.set_weights(new_AR_weights);\n    ar_model.set_constant(new_AR_constant);\n    weights = ar_model.get_weights();\n\n    Serial.print(\"New AR(1) model weight: \");\n    Serial.print(weights[0]);\n    Serial.print(\",\");\n    Serial.print(\"New AR(1) model constant: \");\n    Serial.print(ar_model.get_constant());\n    Serial.print(\",\");\n\n    // Print the initial MA weights and constant.\n    weights = ma_model.get_weights();\n\n    Serial.print(\"Old MA(1) model weight: \");\n    Serial.print(weights[0]);\n    Serial.print(\",\");\n    Serial.print(\"Old MA(1) model constant: \");\n    Serial.print(ma_model.get_constant());\n    Serial.print(\",\");\n\n    // Change the MA weights and constant and print them.\n    ma_model.set_weights(new_MA_weights);\n    ma_model.set_constant(new_MA_constant);\n    weights = ma_model.get_weights();\n\n    Serial.print(\"New MA(1) model weight: \");\n    Serial.print(weights[0]);\n    Serial.print(\",\");\n    Serial.print(\"New MA(1) model constant: \");\n    Serial.print(ma_model.get_constant());\n    Serial.print(\",\");\n\n  }\n\n}\n</code></pre>"},{"location":"examples/change_param/#see-also","title":"See also","text":"<ul> <li>One-step ahead forecasting: perform one-step ahead forecasting;</li> <li>Multi-step ahead forecasting: perform multi-step ahead forecasting using the recursive forecasting method.</li> </ul>"},{"location":"examples/multi-step/","title":"Example - Multi-step ahead forecasting","text":"<p>This example showcases the library's multi-step forecasting capabilities. </p> <p>A 6<sup>th</sup> order Moving Average model is used to forecast the next three measurement values. Each of these forecasts is then compared to the corresponding sensor measurement (i.e. the one-step ahead value is compared to the next sensor measurement, and so on and so forth).</p>"},{"location":"examples/multi-step/#example-code","title":"Example code","text":"<pre><code>/*****************************************************************************\n\n  This example illustrates how to use the library's MA template class to \n  create a simple Moving Average model of order 6 and use it to forecast\n  up to three time steps ahead.\n\n  Note: the weights and constant used in this example are completely\n    arbitrary. This model will most likely perform poorly, and is used here\n    for purely illustrative purposes.\n\n*****************************************************************************/\n\n#include &lt;TimeSeries.h&gt;\n#include &lt;stdint.h&gt;\n\nconstexpr double Ts = 2000.0; // Define sampling time (2 seconds = 2000 ms).\ndouble time = millis(); // Initial time instant.\nconstexpr uint8_t input_pin = A0; // Define input pin.\n\ndouble constant = 2.0; // Define model intercept.\ndouble weights[6] = {1.0, -5.0, 2.5, -1.5, 4.0, -6.0}; // Define model weights.\ndouble data[6] = {0}; // Initialise data array.\ndouble predictions[3] = {0}; // Initialise predictions array for one-step ahead forecasting.\n\nts::MA&lt;6&gt; model(weights, constant); // Instantiate the model. An MA(6) model will be used in this example.\n\nvoid setup() {\n\n  // Initial setup.\n  Serial.begin(9600);\n  pinMode(input_pin, INPUT);\n\n}\n\nvoid loop() {\n\n  double current_time = millis(); // Check the current time.\n  double forecast_3_steps_earlier[3] = {0}; // Array used to store the forecasts made three time-steps ago.\n  double forecast_2_steps_earlier[3] = {0}; // Array used to store the forecasts made two time-steps ago.\n  double forecast_1_step_earlier[3] = {0}; // Array used to store the forecasts made one time-step ago.\n\n  // If enough time has passed, collect another sample.\n  if(current_time - time &gt;= Ts){\n\n    // Prepare the data array to receive a measurement. \n    // Every sample must be shifted by one lag, as we have advanced one lag (i.e. time instant) into the future. \n    // The oldest measurement is discarded.\n    for(size_t i=5; i&lt;1; i--){\n\n      data[i-1] = data[i];\n\n    }\n\n    // Collect a new data sample from the sensor. Update the data array (the most recent sample must come last).\n    data[5] = analogRead(input_pin);\n\n    // Three-step ahead forecast using the most recent data. A prediction horizon of 3 must be specified.\n    model.forecast(data, predictions, 3);\n\n    // Print the most recent measurement and the corresponding forecasts to the serial plotter.\n    Serial.print(\"Sensor_measurement\");\n    Serial.print(data[5]); // Sensor measurement.\n    Serial.print(\",\");\n    Serial.print(\"3-steps earlier forecast\");\n    Serial.print(forecast_3_steps_earlier[2]); // 3-step ahead forecast made 3 time-steps ago.\n    Serial.print(\",\");\n    Serial.print(\"2-steps earlier forecast\");\n    Serial.print(forecast_2_steps_earlier[1]); // 2-step ahead forecast made 2 time-steps ago.\n    Serial.print(\",\");\n    Serial.print(\"1-step earlier forecast\");\n    Serial.println(forecast_1_step_earlier[0]); // 1-step ahead forecast made 1 time-step ago.\n\n    // As we move forward by one time-step, the storage arrays must be shifted back in time (i.e. the forecasts made in the last time-step are shifted to the second-to-last time-step, etc.).\n    for(size_t j=0; j&lt;3; j++){\n\n      forecast_3_steps_earlier[j] = forecast_2_steps_earlier[j];\n      forecast_2_steps_earlier[j] = forecast_1_step_earlier[j];\n      forecast_1_step_earlier[j] = predictions[j];\n\n    }\n\n    // Update reference time instant.\n    time = millis();\n\n  }\n\n}\n</code></pre>"},{"location":"examples/multi-step/#see-also","title":"See also","text":"<ul> <li>One-step ahead forecasting: perform one-step ahead forecasting;</li> <li>Change model parameters: change model parameters after initialising a model.</li> </ul>"},{"location":"TimeSeries/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace ts The library's namespace. <ul> <li>class AR template. </li> <li>class MA template. </li> </ul> </li> </ul>"},{"location":"TimeSeries/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file TimeSeries.h Copyright 2024 Miguel Loureiro. </li> </ul> </li> </ul>"},{"location":"TimeSeries/namespacets/","title":"Namespace ts","text":"<p>Namespace List &gt; ts</p> <p>The library's namespace. More...</p>"},{"location":"TimeSeries/namespacets/#classes","title":"Classes","text":"Type Name class AR &lt;p&gt;template. class MA &lt;q&gt;template."},{"location":"TimeSeries/namespacets/#detailed-description","title":"Detailed Description","text":"<p>Namespace containing the classes provided by the TimeSeries library, namely the AR and MA classes. </p> <p>The documentation for this class was generated from the following file <code>src/TimeSeries.h</code></p>"},{"location":"TimeSeries/classts_1_1AR/","title":"Class ts::AR","text":"<p>template &lt;int p&gt;</p> <p>ClassList &gt; ts &gt; AR</p> <p>template. More...</p>"},{"location":"TimeSeries/classts_1_1AR/#public-functions","title":"Public Functions","text":"Type Name AR () = defaultDefault class constructor. AR (double(&amp;) weights, double constant=0.0) Class constructor. void forecast (double(&amp;) data, double * predictions, int horizon=1) Compute model forecasts. double get_constant () constGet the current intercept. double * get_weights () constGet the current weights. void set_constant (double constant) Set model intercept value. void set_weights (double(&amp;) weights) Set model weights."},{"location":"TimeSeries/classts_1_1AR/#detailed-description","title":"Detailed Description","text":"<p>Template for generating AR model classes.</p> <p>This class template implements the operations associated with an autoregressive (AR) model. These include setting the model's weights and constant and forecasting future values.</p> <p>Template parameters:</p> <ul> <li><code>p</code> Order of the AR model. </li> </ul>"},{"location":"TimeSeries/classts_1_1AR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TimeSeries/classts_1_1AR/#function-ar-12","title":"function AR [1/2]","text":"<p>Default class constructor. <pre><code>ts::AR::AR () = default\n</code></pre></p>"},{"location":"TimeSeries/classts_1_1AR/#function-ar-22","title":"function AR [2/2]","text":"<p>Class constructor. <pre><code>inline ts::AR::AR (\n    double(&amp;) weights,\n    double constant=0.0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>weights</code> Array containing the model's weights. </li> <li><code>constant</code> The model's intercept value. </li> </ul>"},{"location":"TimeSeries/classts_1_1AR/#function-forecast","title":"function forecast","text":"<p>Compute model forecasts. <pre><code>inline void ts::AR::forecast (\n    double(&amp;) data,\n    double * predictions,\n    int horizon=1\n) \n</code></pre></p> <p>This method can be used to compute h step ahead forecasts, where h is the forecast horizon. Its time complexity is O(ph), where p is the order of the model and h is the forecast horizon.</p> <p>Parameters:</p> <ul> <li><code>data</code> Input data. The most recent data point must come last, and the oldest one first. </li> <li><code>predictions</code> Model forecasts. The prediction that goes further into the future comes last. </li> <li><code>horizon</code> Forecast horizon. Optional parameter. Default=1.</li> </ul> <p>Note:</p> <p>The length l of the predictions array must satisfy the following condition: l &gt;= horizon. If l &gt; horizon, the values in the first l positions of the array will be overwritten.</p> <p>Warning:</p> <p>This method resets the predictions array before storing any prediction. This is to make sure that model predictions are not affected by a non-zero value in the array. Keep this in mind when supplying and retrieving a predictions array. </p>"},{"location":"TimeSeries/classts_1_1AR/#function-get_constant","title":"function get_constant","text":"<p>Get the current intercept. <pre><code>inline double ts::AR::get_constant () const\n</code></pre></p> <p>Returns:</p> <p>Model intercept. </p>"},{"location":"TimeSeries/classts_1_1AR/#function-get_weights","title":"function get_weights","text":"<p>Get the current weights. <pre><code>inline double * ts::AR::get_weights () const\n</code></pre></p> <p>Returns:</p> <p>Array of model weights. </p>"},{"location":"TimeSeries/classts_1_1AR/#function-set_constant","title":"function set_constant","text":"<p>Set model intercept value. <pre><code>inline void ts::AR::set_constant (\n    double constant\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>constant</code> New intercept value. </li> </ul>"},{"location":"TimeSeries/classts_1_1AR/#function-set_weights","title":"function set_weights","text":"<p>Set model weights. <pre><code>inline void ts::AR::set_weights (\n    double(&amp;) weights\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>weights</code> Array of new weights. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/TimeSeries.h</code></p>"},{"location":"TimeSeries/classts_1_1MA/","title":"Class ts::MA","text":"<p>template &lt;int q&gt;</p> <p>ClassList &gt; ts &gt; MA</p> <p>template. More...</p>"},{"location":"TimeSeries/classts_1_1MA/#public-functions","title":"Public Functions","text":"Type Name MA () = defaultDefault class constructor. MA (double(&amp;) weights, double constant=0.0) Class constructor. void forecast (double(&amp;) data, double * predictions, int horizon=1) Compute model forecasts. double get_constant () constGet the current intercept. double * get_weights () constGet the current weights. void set_constant (double constant) Set model intercept value. void set_weights (double(&amp;) weights) Set model weights."},{"location":"TimeSeries/classts_1_1MA/#detailed-description","title":"Detailed Description","text":"<p>Template for generating MA model classes.</p> <p>This class template implements the operations associated with a moving average (MA) model. These include setting the model's weights and constant and forecasting future values.</p> <p>Template parameters:</p> <ul> <li><code>q</code> Order of the MA model. </li> </ul>"},{"location":"TimeSeries/classts_1_1MA/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TimeSeries/classts_1_1MA/#function-ma-12","title":"function MA [1/2]","text":"<p>Default class constructor. <pre><code>ts::MA::MA () = default\n</code></pre></p>"},{"location":"TimeSeries/classts_1_1MA/#function-ma-22","title":"function MA [2/2]","text":"<p>Class constructor. <pre><code>inline ts::MA::MA (\n    double(&amp;) weights,\n    double constant=0.0\n) \n</code></pre></p> <p>This constructor can be used to specify model parameters.</p> <p>Parameters:</p> <ul> <li><code>weights</code> Array containing the model's weights. </li> <li><code>constant</code> The model's intercept value. </li> </ul>"},{"location":"TimeSeries/classts_1_1MA/#function-forecast","title":"function forecast","text":"<p>Compute model forecasts. <pre><code>inline void ts::MA::forecast (\n    double(&amp;) data,\n    double * predictions,\n    int horizon=1\n) \n</code></pre></p> <p>This method can be used to compute h step ahead forecasts, where h is the forecast horizon. Its time complexity is O(qh), where q is the order of the model and h is the forecast horizon.</p> <p>Parameters:</p> <ul> <li><code>data</code> Input data. The most recent data point must come last, and the oldest one first. </li> <li><code>predictions</code> Model forecasts. The prediction that goes further into the future comes last. </li> <li><code>horizon</code> Forecast horizon. Optional parameter. Default=1.</li> </ul> <p>Note:</p> <p>The length l of the predictions array must satisfy the following condition: l &gt;= horizon. If l &gt; horizon, the values in the first l positions of the array will be overwritten.</p> <p>Warning:</p> <p>This method resets the predictions array before storing any prediction. This is to make sure that model predictions are not affected by a non-zero value in the array. Keep this in mind when supplying and retrieving a predictions array. </p>"},{"location":"TimeSeries/classts_1_1MA/#function-get_constant","title":"function get_constant","text":"<p>Get the current intercept. <pre><code>inline double ts::MA::get_constant () const\n</code></pre></p> <p>Returns:</p> <p>Model intercept. </p>"},{"location":"TimeSeries/classts_1_1MA/#function-get_weights","title":"function get_weights","text":"<p>Get the current weights. <pre><code>inline double * ts::MA::get_weights () const\n</code></pre></p> <p>Returns:</p> <p>Array of model weights. </p>"},{"location":"TimeSeries/classts_1_1MA/#function-set_constant","title":"function set_constant","text":"<p>Set model intercept value. <pre><code>inline void ts::MA::set_constant (\n    double constant\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>constant</code> New intercept value. </li> </ul>"},{"location":"TimeSeries/classts_1_1MA/#function-set_weights","title":"function set_weights","text":"<p>Set model weights. <pre><code>inline void ts::MA::set_weights (\n    double(&amp;) weights\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>weights</code> Array of new weights. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/TimeSeries.h</code></p>"},{"location":"TimeSeries/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"TimeSeries/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file TimeSeries.h Copyright 2024 Miguel Loureiro. <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"TimeSeries/TimeSeries_8h/","title":"File TimeSeries.h","text":"<p>FileList &gt; src &gt; TimeSeries.h</p> <p>Go to the source code of this file</p> <p>Copyright 2024 Miguel Loureiro. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"TimeSeries/TimeSeries_8h/#namespaces","title":"Namespaces","text":"Type Name namespace ts The library's namespace."},{"location":"TimeSeries/TimeSeries_8h/#classes","title":"Classes","text":"Type Name class AR &lt;p&gt;template. class MA &lt;q&gt;template."},{"location":"TimeSeries/TimeSeries_8h/#detailed-description","title":"Detailed Description","text":"<p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>Author:</p> <p>Miguel Loureiro</p> <p>This file contains all the class definitions for the TimeSeries library.</p> <p>Copyright:</p> <p>Copyright (c) 2024 Miguel Loureiro </p> <p>The documentation for this class was generated from the following file <code>src/TimeSeries.h</code></p>"},{"location":"TimeSeries/TimeSeries_8h_source/","title":"File TimeSeries.h","text":"<p>File List &gt; src &gt; TimeSeries.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __TIME_SERIES_H__\n#define __TIME_SERIES_H__\n\n#include &lt;stdint.h&gt;\n\n\nnamespace ts{\n\n\n    template&lt;int p&gt;\n    class AR{\n\n        public:\n\n\n            AR() = default;\n\n\n            AR(double (&amp;weights)[p], double constant=0.0) : _constant(constant){\n\n                for(size_t i=0; i&lt;p; i++){\n\n                    _weights[i] = weights[i];\n\n                }\n\n            };\n\n\n            double* get_weights() const { return _weights; };\n\n\n            double get_constant() const { return _constant; };\n\n\n            void set_weights(double (&amp;weights)[p]){ \n\n                for(size_t i=0; i&lt;p; i++){\n\n                    _weights[i] = weights[i];\n\n                }\n\n                return; \n            };\n\n\n            void set_constant(double constant){\n\n                _constant = constant;\n\n                return;\n            };\n\n\n            void forecast(double (&amp;data)[p], double* predictions, int horizon=1){\n\n                // Initialise indices and buffer.\n\n                _writing_index = 0;\n                _length_index = p;\n\n                for(size_t i=0; i&lt;p; i++){\n\n                    _data_buffer[i] = data[i];\n\n                }\n\n                for(size_t i=0; i&lt;horizon; i++){\n\n                    predictions[i] = 0.0;\n\n                }\n\n                // Compute forecasts. Most recent data point last.\n\n                for(size_t i=0; i&lt;horizon; i++){\n\n                    for(size_t j=_writing_index; j&lt;_length_index; j++){\n\n                        predictions[i] += _weights[j - _writing_index] * _data_buffer[j % p];\n\n                    }\n\n                    predictions[i] += _constant;\n                    _data_buffer[i % p] = predictions[i]; // What's the right buffer index?\n                    _writing_index++;\n                    _length_index++;\n\n                }\n\n                return;\n\n            };\n\n        private:\n\n            double _weights[p] = {0};\n            double _constant = 0.0;\n            double _data_buffer[p] = {0};\n            size_t _writing_index = 0;\n            size_t _length_index = 0;\n\n    };\n\n\n    template&lt;int q&gt;\n    class MA{\n\n        public:\n\n\n            MA() = default;\n\n\n            MA(double (&amp;weights)[q], double constant=0.0) : _constant(constant){\n\n                for(size_t i=0; i&lt;q; i++){\n\n                    _weights[i] = weights[i];\n\n                }\n\n            };\n\n\n            double* get_weights() const { return _weights; };\n\n\n            double get_constant() const { return _constant; };\n\n\n            void set_weights(double (&amp;weights)[q]){ \n\n                for(size_t i=0; i&lt;q; i++){\n\n                    _weights[i] = weights[i];\n\n                }\n\n                return; \n            };\n\n\n            void set_constant(double constant){\n\n                _constant = constant;\n\n                return;\n            };\n\n\n            void forecast(double (&amp;data)[q], double* predictions, int horizon=1){\n\n                // Initialise indices and buffer. \"Reset\" the offset of the array containing previous predictions.\n\n                _writing_index = 0;\n                _length_index = q;\n                _pred_offset = _pred_offset % q;\n\n                for(size_t i=0; i&lt;q; i++){\n\n                    _data_buffer[i] = data[i] - _pred_buffer[(i + _pred_offset) % q];\n\n                }\n\n                for(size_t i=0; i&lt;horizon; i++){\n\n                    predictions[i] = 0.0;\n\n                }\n\n                // Compute forecasts. Most recent data point last.\n\n                for(size_t i=0; i&lt;horizon; i++){\n\n                    for(size_t j=_writing_index; j&lt;_length_index; j++){\n\n                        predictions[i] += _weights[j - _writing_index] * _data_buffer[j % q];\n\n                    }\n\n                    predictions[i] += _constant;\n\n                    if(i == 0){\n\n                        _pred_buffer[_pred_offset % q] = predictions[i];\n                        _pred_offset++;\n\n                    }\n\n                    _data_buffer[i % q] = 0.0;\n                    _writing_index++;\n                    _length_index++;\n\n                }\n\n                return;\n\n            };\n\n        private:\n\n            double _weights[q] = {0};\n            double _constant = 0.0;\n            double _data_buffer[q] = {0};\n            double _pred_buffer[q] = {0};\n            size_t _writing_index = 0;\n            size_t _length_index = 0;\n            size_t _pred_offset = 0;\n\n    };\n\n};\n\n#endif\n</code></pre>"},{"location":"TimeSeries/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ts The library's namespace. </li> </ul>"},{"location":"TimeSeries/classes/","title":"Class Index","text":""},{"location":"TimeSeries/classes/#a","title":"a","text":"<ul> <li>AR (ts)</li> </ul>"},{"location":"TimeSeries/classes/#m","title":"m","text":"<ul> <li>MA (ts)</li> </ul>"},{"location":"TimeSeries/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ts::AR template. </li> <li>class ts::MA template. </li> </ul>"},{"location":"TimeSeries/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"TimeSeries/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"TimeSeries/class_members/","title":"Class Members","text":""},{"location":"TimeSeries/class_members/#a","title":"a","text":"<ul> <li>AR (ts::AR)</li> </ul>"},{"location":"TimeSeries/class_members/#f","title":"f","text":"<ul> <li>forecast (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_members/#g","title":"g","text":"<ul> <li>get_constant (ts::AR, ts::MA)</li> <li>get_weights (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_members/#m","title":"m","text":"<ul> <li>MA (ts::MA)</li> </ul>"},{"location":"TimeSeries/class_members/#s","title":"s","text":"<ul> <li>set_constant (ts::AR, ts::MA)</li> <li>set_weights (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_members/#_","title":"_","text":"<ul> <li>_constant (ts::AR, ts::MA)</li> <li>_data_buffer (ts::AR, ts::MA)</li> <li>_length_index (ts::AR, ts::MA)</li> <li>_weights (ts::AR, ts::MA)</li> <li>_writing_index (ts::AR, ts::MA)</li> <li>_pred_buffer (ts::MA)</li> <li>_pred_offset (ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_functions/","title":"Class Member Functions","text":""},{"location":"TimeSeries/class_member_functions/#a","title":"a","text":"<ul> <li>AR (ts::AR)</li> </ul>"},{"location":"TimeSeries/class_member_functions/#f","title":"f","text":"<ul> <li>forecast (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_functions/#g","title":"g","text":"<ul> <li>get_constant (ts::AR, ts::MA)</li> <li>get_weights (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_functions/#m","title":"m","text":"<ul> <li>MA (ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_functions/#s","title":"s","text":"<ul> <li>set_constant (ts::AR, ts::MA)</li> <li>set_weights (ts::AR, ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_variables/","title":"Class Member Variables","text":""},{"location":"TimeSeries/class_member_variables/#_","title":"_","text":"<ul> <li>_constant (ts::AR, ts::MA)</li> <li>_data_buffer (ts::AR, ts::MA)</li> <li>_length_index (ts::AR, ts::MA)</li> <li>_weights (ts::AR, ts::MA)</li> <li>_writing_index (ts::AR, ts::MA)</li> <li>_pred_buffer (ts::MA)</li> <li>_pred_offset (ts::MA)</li> </ul>"},{"location":"TimeSeries/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"TimeSeries/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"TimeSeries/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"TimeSeries/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"TimeSeries/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"TimeSeries/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"TimeSeries/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"TimeSeries/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"TimeSeries/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"TimeSeries/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"TimeSeries/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}